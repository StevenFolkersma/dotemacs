#+title: Steven's Emacs configuration
#+author: Steven Folkersma
#+language: en
#+STARTUP: content noflyspell

* Steven's Emacs literal emacs configuration 

This file describes my emacs configuration. 

#+begin_src emacs-lisp
(org-babel-tangle)
#+end_src

#+RESULTS:
| /Users/stevenfolkersma/.config/emacs/init.el |

* The pre initialization of emacs (=early-init.el=)

** The =early-init.el= initialises the package cache

I use the standard =package.el= to manage my Emacs packages [[* The =init.el= section to set up the package manager][The =init.el= section to set up the package manager]]. It works for me and I never had a need for more. If I have to tinker with a package's source code, I use Git ordinarily---no need for a package manager to also be a development tool.

#+begin_src emacs-lisp :tangle "early-init.el"
;; Initialise installed packages at this early stage, by using the
;; available cache.  I had tried a setup with this set to nil in the
;; early-init.el, but (i) it ended up being slower and (ii) various
;; package commands, like `describe-package', did not have an index of
;; packages to work with, requiring a `package-refresh-contents'.
(setq package-enable-at-startup t)
#+end_src


** The =early-init.el= tweaks to startup time and garbage collection

I do not have a deep understanding of "garbage collection", though I
have learnt through trial and error that I can maximise the threshold
during startup to make Emacs boot a bit faster. What I am doing here
is to arrange for the relevant values to be set to very high values
during startup and then be brought down to something more practical
once Emacs is done loading.

#+begin_src emacs-lisp :tangle "early-init.el"
;; Temporarily increase the garbage collection threshold.  These
;; changes help shave off about half a second of startup time.  The
;; `most-positive-fixnum' is DANGEROUS AS A PERMANENT VALUE.  See the
;; `emacs-startup-hook' a few lines below for what I actually use.
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

;; Same idea as above for the `file-name-handler-alist' and the
;; `vc-handled-backends' with regard to startup speed optimisation.
;; Here I am storing the default value with the intent of restoring it
;; via the `emacs-startup-hook'.
(defvar steven-emacs--file-name-handler-alist file-name-handler-alist)
(defvar steven-emacs--vc-handled-backends vc-handled-backends)

(setq file-name-handler-alist nil
      vc-handled-backends nil)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 100 100 8)
                  gc-cons-percentage 0.1
                  file-name-handler-alist steven-emacs--file-name-handler-alist
                  vc-handled-backends steven-emacs--vc-handled-backends)))
#+end_src

** The =early-init.el= names the default frame

Naming frames allows you to select them using completion. Emacs can do this (=M-x select-frame-by-name=), though it is not always reliable as it depends on the window manager (it works fine on GNOME, from what I can tell). For minimalist window managers on Linux, something like the ~rofi~ program can select system windows based on their name.

#+begin_src emacs-lisp :tangle "early-init.el"
(add-hook 'after-init-hook (lambda () (set-frame-name "home")))
#+end_src


* The main initialization of emacs (=init.el=)

** The =init.el= section to set up the package manager

The =package.el= is built into Emacs. We do not need to load it explicitly, as it will be called
by ~use-package~ when it needs it (also Prot's video about
[[https://protesilaos.com/codelog/2024-07-23-emacs-use-package-essentials/][~use-package~ essentials]] (2024-07-23)). Since the introduction of the
=early-init.el= file, we also do not need to initialise the packages
at this point: we activate the cache instead.

With regard to the settings here, make sure to read my article about
package archives, pinning packages, and setting priorities:
<https://protesilaos.com/codelog/2022-05-13-emacs-elpa-devel/>.

#+begin_src emacs-lisp :tangle "init.el"
;; Also read: <https://protesilaos.com/codelog/2022-05-13-emacs-elpa-devel/>
(setq package-archives
      '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa" . "https://melpa.org/packages/")))

;; Highest number gets priority (what is not mentioned has priority 0)
(setq package-archive-priorities
      '(("gnu-elpa" . 3)
        ("melpa" . 2)
        ("nongnu" . 1)))

(add-to-list 'display-buffer-alist
             '("\\`\\*\\(Warnings\\|Compile-Log\\)\\*\\'"
               (display-buffer-no-window)
               (allow-no-window . t)))
#+end_src

#+RESULTS:
| \`\*Calendar\*\' | (display-buffer-below-selected) |                            |                       |
| \`\*\(Warnings\  | Compile-Log\)\*\'               | (display-buffer-no-window) | (allow-no-window . t) |


** The =init.el= section to set folder with custom .el files
#+begin_src emacs-lisp :tangle "init.el" :results silent
(add-to-list 'load-path "~/.config/emacs/steven")
#+end_src

** The =init.el= section to stop emacs from saving backup files
By default, Emacs tries to lock down files so that they are not
modified by other programs. It also keeps backups.
*Note*: I am not sure it removing lockfiles is smart, since I edit the files on mulitple machines.

#+begin_src emacs-lisp :tangle "init.el"
  (setq make-backup-files nil)
  (setq backup-inhibited nil) ; Not sure if needed, given `make-backup-files'
  (setq create-lockfiles nil)
#+end_src

#+RESULTS:


** The =init.el= section to set the custom user file
By default, Emacs writes persistent customisations to the end of the user's init file. These are encapsulated in a "custom" block. Emacs writes those whenever the user does something with =M-x customize= or related.

I personally prefer writing the actual Elisp over using the interface of =M-x customize=. I also want my init file to only ever contain what I wrote and to never---ever!---evaluate code I have not called myself.

As such, I want to set the ~custom-file~ variable to tell Emacs to write its persistent variables to that file instead of my =init.el=.
Though since I have no intent to ever use this file, I choose to make it disposable by placing it inside of the =/tmp= directory (this is what the ~make-temp-file~ function does). So when I close the computer, the file is gone. Finally, I do not invoke the ~load~
function because I will never rely on the ~custom-file~. 

#+begin_src emacs-lisp :tangle "init.el"
  ;; Disable the damn thing by making it disposable.
  (setq custom-file (make-temp-file "emacs-custom-"))
  (load custom-file :no-error-if-file-is-missing)
#+end_src

#+RESULTS:
: t


** The =init.el= setup of the startup screen
#+begin_src emacs-lisp :tangle "init.el"
  (setq initial-buffer-choice t)
  (setq initial-major-mode 'emacs-lisp-mode)
  (setq-default inhibit-startup-screen t)
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t) 
  (setq initial-scratch-message
  ""      
  )
#+end_src

#+RESULTS:

#+end_src

** The =init.el= section to add basic keybindings
Quality of life snipper from Prot's setup.
#+begin_src emacs-lisp :tangle "init.el"
(defun steven/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(define-key global-map (kbd "C-g") #'steven/keyboard-quit-dwim)
#+end_src

#+RESULTS:
: steven/keyboard-quit-dwim

Some settings from the NANO config (I use prot's code for modifying C-g, which is normally also included in NANO emacs)

#+begin_src emacs-lisp :tangle "init.el"
(defun nano-kill ()
  "Delete frame or kill emacs if there is only one frame left"

  (interactive)
  (condition-case nil
      (delete-frame)
    (error (save-buffers-kill-terminal))))

(bind-key "C-x k" #'kill-current-buffer)
(bind-key "C-x C-c" #'nano-kill)
(bind-key "C-x C-r" #'recentf-open)
(bind-key "M-n" #'make-frame)
(bind-key "C-z"  nil) ;; No suspend frame
(bind-key "C-<wheel-up>" nil) ;; No text resize via mouse scroll
(bind-key "C-<wheel-down>" nil) ;; No text resize via mouse scroll
#+end_src

#+begin_src emacs-lisp :tangle "init.el"
(global-set-key "\C-x\C-m" 'execute-extended-command)

(global-set-key "\C-c\C-m" 'execute-extended-command)

(global-set-key "\C-w" 'backward-kill-word)

(global-set-key "\C-c\C-k" 'kill-region)

(global-unset-key (kbd "C-x m"))

#+end_src

#+RESULTS:

** The =init.el= section with basic sane settings

Those three belong in the early-init.el, but I am putting them here
for convenience.  If the early-init.el exists in the same directory
as the init.el, then Emacs will read+evaluate it before moving to
the init.el.

#+begin_src emacs-lisp :tangle "init.el"
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(blink-cursor-mode -1)
(global-hl-line-mode 1)
(pixel-scroll-precision-mode 1)
(set-default-coding-systems 'utf-8)
(setq-default indent-tabs-mode nil
              ring-bell-function 'ignore
              select-enable-clipboard t)  
#+end_src

#+RESULTS:
: t

** The =init.el= section setting the fonts

Set default font for all text. *IMPORTANT*: Font setting don’t take effect during startup (only when run later) because Emacs initializes its faces and frame system after much of your init file runs.

So when you call set-face-attribute too early, Emacs overwrites those faces once it finishes setting up the first frame or when the theme loads.

#+begin_src emacs-lisp :tangle "init.el"
(defun steven/setup-fonts-linux ()
  (let ((mono-spaced-font "Roboto Mono")
        (proportionately-spaced-font "DejaVu Sans"))
    (set-face-attribute 'default nil :family mono-spaced-font :weight 'normal :height 180)
    (set-face-attribute 'fixed-pitch nil :family mono-spaced-font :height 1.0)
    (set-face-attribute 'variable-pitch nil :weight 'normal :family proportionately-spaced-font :height 1.1)))

(defun steven/setup-fonts-mac ()
  (let ((mono-spaced-font "Roboto Mono")
        (proportionately-spaced-font "DejaVu Sans"))
    (set-face-attribute 'default nil :family mono-spaced-font :weight 'thin :height 170)
    (set-face-attribute 'fixed-pitch nil :family mono-spaced-font :height 1.0)
    (set-face-attribute 'variable-pitch nil :weight 'normal :family proportionately-spaced-font :height 1.1)))

;; Run after Emacs initializes and after any theme is applied
(if (eq system-type 'darwin)
    ;; macOS-specific configuration
   (progn
    (add-hook 'after-init-hook #'steven/setup-fonts-mac)
    (add-hook 'after-load-theme-hook #'steven/setup-fonts-mac))
  ;; Non-macOS configuration
  (progn
   (add-hook 'after-init-hook #'steven/setup-fonts-linux)
   (add-hook 'after-load-theme-hook #'steven/setup-fonts-linux)))

(set-display-table-slot standard-display-table 'truncation (make-glyph-code ?…))
(set-display-table-slot standard-display-table 'wrap (make-glyph-code ?–))
#+end_src

#+RESULTS:
: 8211

** The =init.el= section on the NANO theme setup

First, load the colors

#+begin_src emacs-lisp :tangle "init.el"
(defun nano-theme-set-light ()
  "Apply light Nano theme base."
  ;; Colors from Material design at https://material.io/
  (setq frame-background-mode    'light)
  (setq nano-color-foreground "#37474F") ;; Blue Grey / L800
  (setq nano-color-background "#FFFFFF") ;; White
  (setq nano-color-highlight  "#ECEFF1") ;; Very Light Grey
  (setq nano-color-critical   "#FF6F00") ;; Amber / L900
  (setq nano-color-salient    "#673AB7") ;; Deep Purple / L500
  (setq nano-color-strong     "#000000") ;; Black
  (setq nano-color-popout     "#FFAB91") ;; Deep Orange / L200
  (setq nano-color-subtle     "#ECEFF1") ;; Blue Grey / L50
  (setq nano-color-faded      "#B0BEC5") ;; Blue Grey / L200
  ;; to allow for toggling of the themes.
  (setq nano-theme-var "light")
  )

(defun nano-theme-set-dark ()
  "Apply dark Nano theme base."
  ;; Colors from Nord theme at https://www.nordtheme.com
  (setq frame-background-mode     'dark)
  (setq nano-color-foreground "#ECEFF4") ;; Snow Storm 3  / nord  6
  (setq nano-color-background "#2E3440") ;; Polar Night 0 / nord  0
  (setq nano-color-highlight  "#3B4252") ;; Polar Night 1 / nord  1
  (setq nano-color-critical   "#EBCB8B") ;; Aurora        / nord 11
  (setq nano-color-salient    "#81A1C1") ;; Frost         / nord  9
  (setq nano-color-strong     "#ECEFF4") ;; Snow Storm 3  / nord  6
  (setq nano-color-popout     "#D08770") ;; Aurora        / nord 12
  (setq nano-color-subtle     "#434C5E") ;; Polar Night 2 / nord  2
  (setq nano-color-faded      "#677691") ;;
  ;; to allow for toggling of the themes.
  (setq nano-theme-var "dark")
  )

#+end_src

I do not load nano-theme-dark and -light as they only set the colours. 

#+begin_src emacs-lisp :tangle "init.el"
  (require 'nano-base-colors)
  (require 'nano-faces)
  (require 'nano-modeline)
  (require 'nano-theme)
;  (require 'nano-theme-dark)
;  (require 'nano-theme-light)

  (cond                                                       
   ((member "-default" command-line-args) t)                  
   ((member "-dark" command-line-args) (nano-theme-set-dark)) 
   (t (nano-theme-set-light)))                                
  (call-interactively 'nano-refresh-theme)                    

#+end_src

#+RESULTS:

** The =init.el= setup of nerd icon
At first time use you need to do M-x and run `nerd-icons-install-fonts' to get the
font files.  Then restart Emacs to see the effect.

#+begin_src emacs-lisp :tangle "init.el"
(use-package nerd-icons
  :ensure t)
#+end_src

Adds nerd icons to vertico minibuffer output
#+begin_src emacs-lisp :tangle "init.el"
(use-package nerd-icons-completion
  :ensure t
  :after marginalia
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

Adds nerd icons to corfu completion list.
#+begin_src emacs-lisp :tangle "init.el"
(use-package nerd-icons-corfu
  :ensure t
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

Adds nerd icons to dired list
#+begin_src emacs-lisp :tangle "init.el"
(use-package nerd-icons-dired
  :ensure t
  :hook
  (dired-mode . nerd-icons-dired-mode))
#+end_src

** The =init.el= setting windows styling and wrapping

Set the type of line numbers (I guess I can also set it to relative?). However I dont need them so they are not shown.
Set *fringe-mode* to 0, no fringes on the window edge for that fresh look

#+begin_src emacs-lisp :tangle "init.el"
(setq display-line-numbers-type t)
;;(fringe-mode 1)
(setq default-frame-alist
   '((width  . 72) (left-fringe . 0) (right-fringe . 0)
    (internal-border-width . 32) (vertical-scroll-bars . nil)
    (bottom-divider-width . 0) (right-divider-width . 32)
    (undecorated-round . t)))
(modify-frame-parameters nil default-frame-alist)
(setq-default pop-up-windows nil)

;; different setting for GNOME

(if (eq system-type 'darwin)
    ;; macOS-specific configuration
    (set-frame-parameter nil 'undecorated-round t)
  ;; Non-macOS configuration
  (set-frame-parameter nil 'undecorated nil))
#+end_src



#+RESULTS:

This sets line wrapping, visual line mode move text to a new line without actually add a line number.
#+begin_src emacs-lisp :tangle "init.el"
(setq-default fill-column 80)
;;(global-visual-line-mode 1)
;; set visual-line-mode only with text
(add-hook 'text-mode-hook 'visual-line-mode) 
(add-hook 'text-mode-hook 'visual-wrap-prefix-mode)
#+end_src

#+RESULTS:
| visual-wrap-prefix-mode | denote-fontify-links-mode-maybe | visual-line-mode | text-mode-hook-identify |

** The =init.el= adding a function to toggle frame width

This function is to toggle the width from 'half' to 'wide', it now only works on mac. I should make it so it changes the width based on the display size. 
#+begin_src emacs-lisp :tangle "init.el"
(defun center-frame ()
  "Center the current frame on the display."
  (let* ((frame (selected-frame))
         (frame-w (frame-pixel-width frame))
         (frame-h (frame-pixel-height frame))
         (display-w (display-pixel-width))
         (display-h (display-pixel-height))
         (pos-x (/ (- display-w frame-w) 2))
         (pos-y (/ (- display-h frame-h) 2)))
    (set-frame-position frame (max pos-x 0) (max pos-y 0))))

;; Hook into startup
(add-hook 'window-setup-hook #'center-frame)

(defun steven/toggle-frame-width ()
  "Toggle the frame width between narrow and wide, and adjust height to fit display."
  (interactive)
  (let* ((frame (selected-frame))
         (current-width (frame-width frame))
         (narrow-width 72)
         (wide-width 135)
         (char-height (frame-char-height frame))
         (display-height (display-pixel-height))
         (usable-height (- display-height 40)) 
         (frame-rows (/ usable-height char-height)))
    (set-frame-height frame frame-rows)
    (set-frame-width frame (if (> current-width narrow-width)
                               narrow-width
                             wide-width)))
    (center-frame))

(global-set-key (kbd "C-c t w") 'steven/toggle-frame-width)
#+end_src

#+RESULTS:
: steven/toggle-frame-width

** The =init.el= setting to delete inserted text
#+begin_src emacs-lisp :tangle "init.el"
(use-package delsel
  :ensure nil
  :hook (after-init . delete-selection-mode))
#+end_src

#+RESULTS:
| delete-selection-mode | org-persist-load-all | tramp-register-archive-autoload-file-name-handler | magit-maybe-define-global-key-bindings | table--make-cell-map |

** The =init.el= to setup trash for deleted files
#+begin_src emacs-lisp :tangle "init.el"
(use-package trashed
  :ensure t
  :commands (trashed)
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** The =init.el= setup of dired

- I turn on hide details because I dont need info on permission etc., it can be toggled when needed.
- hl-line-mode: this makes the current line always highlighted
- By default the icons are shown, which is setup in [[*Theme and nerd icons setup][Theme and nerd icons setup]]

#+begin_src emacs-lisp :tangle "init.el"
  (use-package dired
    :ensure nil
    :commands (dired)
    :hook
    ((dired-mode . dired-hide-details-mode)
     (dired-mode . hl-line-mode)
     (dired-mode . dired-omit-mode))
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-alh --group-directories-first")
    (use-package dired-x
       :ensure nil  ;; also built-in
       :config
       (setq dired-omit-files
            (concat dired-omit-files
             "\\|^\\.DS_Store$"
             "\\|^\\.stfolder$"
             "\\|^\\.localized$"))))

(defun steven/dired-layout ()
  "Custom behaviors for dired layout."
  ;;truncate-lines is buffer local, so can be safely changed
  (setq truncate-lines t))

;; The above does not work because the 'hide details
;; mode' is also hooked to dired mode and overrides my
;; settings. Check C-h v dired-mode-hook.

;; The following appends it to the hook list at the end
(add-hook 'dired-mode-hook
          #'steven/dired-layout
          t)


#+end_src

#+RESULTS:
| denote-dired-mode | dired-extra-startup | dired-omit-mode | hl-line-mode | dired-hide-details-mode | nerd-icons-dired-mode | #[nil ((setq truncate-lines t)) nil] | steven/dired-layour | steven/dired-layout |

** The =init.el= section on dired-subtree
Dired subtree is to show subtrees of folder with TAB
#+begin_src emacs-lisp :tangle "init.el"
(use-package dired-subtree
  :ensure t
  :after dired
  :bind
  ( :map dired-mode-map
    ("<tab>" . dired-subtree-toggle)
    ("TAB" . dired-subtree-toggle)
    ("<backtab>" . dired-subtree-remove)
    ("S-TAB" . dired-subtree-remove))
  :config
  (setq dired-subtree-use-backgrounds nil))
#+end_src

** The =init.el= section on dired-preview
#+begin_src emacs-lisp :tangle "init.el"
(use-package dired-preview
    :ensure t
    :config
    (setq dired-preview-delay 0.7)
    (setq dired-preview-max-size (expt 2 20))
    (setq dired-preview-ignored-extensions-regexp
          (concat "\\."
                  "\\(gz\\|"
                  "zst\\|"
                  "tar\\|"
                  "xz\\|"
                  "rar\\|"
                  "zip\\|"
                  "iso\\|"
                  "epub"
                  "\\)")))

#+end_src


** The =init.el= section to setup colorful mode

#+begin_src emacs-lisp :tangle "init.el"
(use-package colorful-mode
  ;; :diminish
  :ensure t ; Optional
  :custom
  (colorful-use-prefix t)
  (colorful-prefix-string " ")
  (colorful-only-strings 'only-prog)
  (css-fontify-colors nil)
  :config
  (global-colorful-mode t)
  (add-to-list 'global-colorful-modes 'helpful-mode))

#+end_src

#+RESULTS:
: t

** The =init.el= setup of the dictionary

- The gcide dictionary specifically pulls from Webster's 1913 content. If you omit the dictionary-default-dictionary setting, you'll get results from all available dictionaries on dict.org (including Webster's).

- Interactive search: Run M-x dictionary-search RET (or your custom keybinding like C-c d), enter a word (e.g., "serendipity"), and press Enter. Results appear in a new buffer with definitions, etymology, and hyperlinks for related words.
- Lookup word at point: Position your cursor on a word and run M-x dictionary-lookup-definition. This queries the default dictionary (GCIDE/Webster's).
- Match/regex search: Use M-x dictionary-match for partial matches (e.g., "seren*").

The results buffer supports navigation: hyperlinks (e.g., for synonyms or related terms) are clickable, and you can browse history with dictionary-previous/dictionary-next.

#+begin_src emacs-lisp :tangle "init.el"
;; Set the default server to dict.org (avoids prompting each time)
(setq dictionary-server "dict.org")

;; Optional: Set default dictionary to GCIDE for Webster's 1913
(setq dictionary-default-dictionary "gcide")

;; Optional: Bind a key for quick lookups (e.g., on the current word at point)
(global-set-key (kbd "C-c d") #'dictionary-search)


#+end_src

#+RESULTS:
: steven-flyspell-dict-indicator

** The =init.el= section to setup spell-checking

For spell checking I use hunspell, both for Linux (dnf) and macOS (brew). Dutch and English spelling libraries need to be added. Current dictionaries available by hunspell are listed with the following command:

#+begin_src bash
hunspell -D
#+end_src

My emacs functions expect *nl_NL* and *en_GB* libraries to be installed.

- nl_NL dictionaries from opentaal.nl: [[https://github.com/OpenTaal/opentaal-hunspell][GitHub - OpenTaal/opentaal-hunspell]]
- en_GB dictionaries: [[https://github.com/marcoagpinto/aoo-mozilla-en-dict][GitHub - marcoagpinto/aoo-mozilla-en-dict: English Dictionaries Project]]

Dictionary files should be placed in: 
- *Linux*: /usr/share/hunspell. 
- *macOS*: ~/Library/Spelling. 

Important command: C-; to autocorrect previous word before point. Middle click to correct a marked word. M-$ to open context menu for word on point. I have turned off the automatic hook to text mode, such that I can activate it myself.

*IMPORTANT* Underlines for correct/double words are set in nano-faces / nano-theme! 

#+begin_src emacs-lisp :tangle "init.el"
;; Use Hunspell as the spell-checker
(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-really-hunspell t))

;; Default to Dutch
(setq ispell-dictionary "nl_NL")
(setq flyspell-default-dictionary "nl_NL")

;; Tell Emacs where to find the dictionaries (optional if auto-detected)
(setq ispell-local-dictionary-alist
      '(("en_GB" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_GB") nil utf-8)
        ("nl_NL" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "nl_NL") nil utf-8)))

;(add-hook 'text-mode-hook 'flyspell-mode)

(defun steven/toggle-spell-language ()
  "Toggle between English and Dutch Hunspell dictionaries."
  (interactive)
  (let ((current-dict ispell-current-dictionary))
    (cond
     ((string= current-dict "en_GB")
      (ispell-change-dictionary "nl_NL")
      (message "Switched dictionary to Dutch (nl_NL)"))
     ((string= current-dict "nl_NL")
      (ispell-change-dictionary "en_GB")
      (message "Switched dictionary to English (en_GB)"))
     (t
      (ispell-change-dictionary "en_GB")
      (message "Defaulted dictionary to English (en_GB)"))))
     (flyspell-buffer))

#+end_src

#+RESULTS:
: steven/toggle-spell-language

** The =init.el= section to add an org statup hook for spell dictionary

This creates a hook to text mode and can set the following startup to org files:
- spell NL
- spell EN
- noflyspell
It seems to work but I need to understand it better.

#+begin_src emacs-lisp
(defun steven/apply-flyspell-from-startup ()
  "Check for a #+STARTUP: line to configure flyspell in text/org modes."
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^#\\+STARTUP:[ \t]+\\(.*\\)$" nil t)
      (let ((args (split-string (match-string 1) "[ \t]+" t)))
        (cond
         ;; Disable flyspell
         ((member "noflyspell" args)
          (flyspell-mode -1)
          (message "Flyspell disabled by #+STARTUP directive."))

         ;; Set dictionary explicitly, e.g. #+STARTUP: spell en_GB
         ((and (member "spell" args)
               (> (length args) 1))
          (let ((dict (nth 1 args)))
            (when (flyspell-mode 1)
              (ispell-change-dictionary dict)
              (message "Flyspell dictionary set to %s by #+STARTUP directive." dict))))

         ;; Enable flyspell normally if just “spell”
         ((member "spell" args)
          (flyspell-mode 1)
          (message "Flyspell enabled by #+STARTUP directive."))))
          (nano-modeline-update-windows))))


(add-hook 'text-mode-hook
          (lambda ()
            (steven/apply-flyspell-from-startup)))

#+end_src

** The =init.el= section on 'electric' behaviour

Emacs describes as "electric" any behaviour that tries to be smart
about how to handle a given action. The ~electric-pair-mode~, for
example, automatically inserts a closing parenthesis when the user
inputs an opening parenthesis. Same idea with quotes, performed by the
~electric-quote-mode~. While the ~electric-indent-mode~ tries to be
smart about how to indent a line, which is fine for programming
purposes, it makes a mess of things in Org and related because you
have to delete back to the beginning of a line if you want to "escape"
from the indentation of a list or something.

If I need to manually wrap the symbol at point or a region in a pair
of characters, I use my ~prot-pair-insert~ command ([[#h:48d2bab5-241f-49dd-9554-8a4dcedce75e][The =prot-emacs-essentials.el= section about =prot-pair.el= (insert character pairs)]]).

#+begin_src emacs-lisp :tangle "init.el"

  ;; Enable electric-indent-mode globally
  (electric-indent-mode -1)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  
#+end_src

** The =init.el= setup of completion with vertico
Configure the minibuffer and completions.
- vertico-cycle: So I can go from bottom item to top item by down arrow or C-n
- vertico-resize nil: always keep the same size
#+begin_src emacs-lisp :tangle "init.el"
  (use-package vertico
    :ensure t
    :config
    (setq vertico-cycle t)
    (setq vertico-resize  nil)
    :hook (after-init . vertico-mode))
#+end_src

Annotate completion candidates with richer information
#+begin_src emacs-lisp :tangle "init.el"
(use-package marginalia
  :ensure t
  :hook (after-init . marginalia-mode))
#+end_src

Basically sets up fuzzy find, order of words does not matter. 
#+begin_src emacs-lisp :tangle "init.el"
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic))
  (setq completion-category-defaults nil)
  (setq completion-category-overrides nil))
#+end_src


** The =init.el= setup of search with consult
Essential package for searching etc.
From Prot's config: The `consult' package provides lots of commands that are enhanced
variants of basic, built-in functionality.  One of the headline features of `consult' is its preview facility, where it shows in another Emacs window the context of what is currently matched in the minibuffer.
*Note Steven*: I wanted to do keybinding with C-f, but this is forward word in emacs! Current mnemonic for their prefix is "alternative search" (as opposed to the basic C-s or C-r keys).
#+BEGIN_SRC emacs-lisp :tangle "init.el"
(use-package consult
  :ensure t
  :bind (;; A recursive grep
         ("M-s M-g" . consult-grep)
         ;; Search for files names recursively
         ("M-s M-f" . consult-find)
         ;; Search through the outline (headings) of the file
         ("M-s M-o" . consult-outline)
         ;; Search the current buffer
         ("M-s M-l" . consult-line)
         ;; Switch to another buffer, or bookmarked file, or recently
         ;; opened file.
         ("C-x C-b" . consult-buffer))
   :config
   (setq consult-buffer-sources
      '(consult--source-hidden-buffer
        consult--source-buffer
        consult--source-bookmark
        ;; consult--source-recent-file   ; ← disable recent files
        ))
   (setq consult-preview-key 'any)
   (consult-customize consult-find 
                   :state (consult--file-preview))
   (consult-customize consult-fd 
                   :state (consult--file-preview))) ;; Preview every candidate as you move)
#+END_SRC

#+RESULTS:
: consult-buffer

** The =init.el= section on consult-notes

#+begin_src emacs-lisp :tangle "init.el"
(use-package consult-notes
  :ensure t
  :commands (consult-notes
             consult-notes-search-in-all-notes)
  :config
  (setq consult-notes-file-dir-sources '(("Huiswiki" ?h "~/Documents/Huiswiki/")
                                         ("Systemwiki" ?s "~/Documents/Systemwiki")))
  (setq consult-notes-org-headings-files '("~/Documents/Org/general.org"
                                           "~/Documents/Org/main.org"))
  (consult-notes-org-headings-mode)
  (when (locate-library "denote")
    (consult-notes-denote-mode)))
#+end_src

#+RESULTS:
: t

** The =init.el= section on consult-dir

#+begin_src emacs-lisp :tangle "init.el"
(use-package consult-dir
  :ensure t
  :bind (("C-x C-d" . consult-dir)
         :map minibuffer-local-completion-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file))
  :config
  (setq consult-dir-default-command #'consult-find))
#+end_src

#+RESULTS:
: consult-dir-jump-file

** The =init.el= section with embark setup

This is copied from prot's setup! I need to check how the :bind setup works, it might load the libraries not how I expect (= checkout how use-package works

#+begin_src emacs-lisp :tangle "init.el"
;;; Extended minibuffer actions and more (embark.el)

(use-package embark
  :ensure t
  :bind
  ( :map minibuffer-local-map
    ("C-c C-c" . embark-collect)
    ("C-c C-e" . embark-export)))

;; Needed for correct exporting while using Embark with Consult
;; commands.
(use-package embark-consult
  :ensure t
  :after (embark consult))
#+end_src

#+RESULTS:


** The =init.el= section to save mini buffer history
Toggle saving of minibuffer history. This is build in. Vertico can use this to find recently opened files and put these results at the top. 
#+begin_src emacs-lisp :tangle "init.el"
(use-package savehist
  :ensure nil ; it is built-in
  :hook (after-init . savehist-mode))
#+end_src


** The =init.el= section to save recent files
The built-in `recentf-mode' keeps track of recently visited files. You can then access those through the `consult-buffer' interface or with `recentf-open'/`recentf-open-files'.

I do not use this facility, because the files I care about are either in projects or are bookmarked.

#+begin_src emacs-list :tangle "init.el"
(use-package savehist
  :ensure nil ; it is built-in
  :hook (after-init . recentf-mode))
#+end_src

** The =init.el= to relocate auto-save files

Normally auto-save files (which I find usefull) are saved in the same folder as the edited file. This then also shows up in consult-find, fd and grep, which is annoying. Now they are stored in a given folder.

I think this is causing issues! Need to check

#+begin_src emacs-lisp :tangle "init.el"

;; Redirect auto-saves
(setq auto-save-file-name-transforms
      `((".*" "~/.config/emacs/auto-saves/\\1" t)))

#+end_src

#+RESULTS:
| .* | ~/.config/emacs/auto-saves/\1 | t |

** The =init.el= section with corfu setup

Corfu enhances in-buffer completion with a small completion popup. The current candidates are shown in a popup below or above the point, and can be selected by moving up and down. Corfu is the minimalistic in-buffer completion counterpart of the Vertico minibuffer UI. 
Current setup is to press <TAB> to see completion.

This can also be used inside an org source block, but the source block needs to be opened in an elisp-mode buffer using ~C-c '~

#+begin_src emacs-lisp :tangle "init.el"
(use-package corfu
  :ensure t
  :hook (after-init . global-corfu-mode)
  :bind (:map corfu-map ("<tab>" . corfu-complete))
  :config
  (setq tab-always-indent 'complete)
  (setq corfu-preview-current nil)
  (setq corfu-min-width 20)

  (setq corfu-popupinfo-delay '(1.25 . 0.5))
  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'

  ;; Sort by input history (no need to modify `corfu-sort-function').
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)))
#+end_src


** The =init.el= setup of denote

Currently the directory is set as /Documents/notes, I can include all subdirectory by add 'expand-tree' or so before the dir. Check Prot's setup for that. 
#+begin_src emacs-lisp :tangle "init.el"
  (use-package denote
    :ensure t
    :hook
    ;; If you use Markdown or plain text files you want to fontify links
    ;; upon visiting the file (Org renders links as buttons right away).
    ((text-mode . denote-fontify-links-mode-maybe)
     ;; Highlight Denote file names in Dired buffers.  Below is the
     ;; generic approach, which is great if you rename files Denote-style
     ;; in lots of places as I do.
     ;;
     ;; If you only want the `denote-dired-mode' in select directories,
     ;; then modify the variable `denote-dired-directories' and use the
     ;; following instead:
     ;;
     ;;  (dired-mode . denote-dired-mode-in-directories)
     (dired-mode . denote-dired-mode))
    :bind
    ;; Denote DOES NOT define any key bindings.  This is for the user to
    ;; decide.  Here I only have a subset of what Denote offers.
    ( :map global-map
      ("C-c n n" . denote)
      ("C-c n N" . denote-type)
      ("C-c n d" . denote-sort-dired)
      ;; Note that `denote-rename-file' can work from any context, not
      ;; just Dired buffers.  That is why we bind it here to the
      ;; `global-map'.
      ;;
      ;; Also see `denote-rename-file-using-front-matter' further below.
      ("C-c n r" . denote-rename-file)
      ;; If you intend to use Denote with a variety of file types, it is
      ;; easier to bind the link-related commands to the `global-map', as
      ;; shown here.  Otherwise follow the same pattern for
      ;; `org-mode-map', `markdown-mode-map', and/or `text-mode-map'.
      :map org-mode-map
       ("C-c n i" . denote-link) ; "insert" mnemonic
       ("C-c n I" . denote-add-links)
       ("C-c n b" . denote-backliNks)
       ("C-c n R" . denote-rename-file-using-front-matter)
      ;; Key bindings specifically for Dired.
      :map dired-mode-map
      ("C-c C-d C-i" . denote-dired-link-marked-notes)
      ("C-c C-d C-r" . denote-dired-rename-marked-files)
      ("C-C C-d C-k" . denote-dired-rename-marked-files-with-keywords)
      ("C-c C-d C-f" . denote-dired-rename-marked-files-using-front-matter))
    :config
    ;; Remember to check the doc strings of those variables.
    (setq denote-directory "~/Documents/Notes" )

    ;; If you want to have a "controlled vocabulary" of keywords,
    ;; meaning that you only use a predefined set of them, then you want
    ;; `denote-infer-keywords' to be nil and `denote-known-keywords' to
    ;; have the keywords you need.
    (setq denote-known-keywords '("emacs" "idea" "note" "recipe" "bikes" "config"))
    (setq denote-infer-keywords t)
    (setq denote-sort-keywords t)
    (setq denote-buffer-name-prefix "[D] ") ; to identify all Denote buffers
    (setq denote-rename-buffer-format "%D")
    (denote-rename-buffer-mode 1))
#+end_src 


** The =init.el= section on denote-consult

This make Denote Buffers have their own section in consult-buffer. Consult-denote-find searches in note folder. Cannot also be setup to include denote silos (check manual). Also check out consult-note: [[https://github.com/mclear-tools/consult-notes][consult-note GitHub Page
]]
#+begin_src emacs-lisp :tangle "init.el"
(use-package consult-denote
  :ensure t
  :bind
  (("C-c n f" . consult-denote-find)
   ("C-c n g" . consult-denote-grep))
  :config
  (consult-denote-mode 1))
#+end_src

** The =init.el= section on denote-org

#+begin_src emacs-lisp :tangle "init.el"
(use-package denote-org
  :ensure t
  :commands
  ;; I list the commands here so that you can discover them more
  ;; easily.  You might want to bind the most frequently used ones to
  ;; the `org-mode-map'.
  ( denote-org-link-to-heading
    denote-org-backlinks-for-heading

    denote-org-extract-org-subtree

    denote-org-convert-links-to-file-type
    denote-org-convert-links-to-denote-type

    denote-org-dblock-insert-files
    denote-org-dblock-insert-links
    denote-org-dblock-insert-backlinks
    denote-org-dblock-insert-missing-links
    denote-org-dblock-insert-files-as-headings))
#+end_src

#+RESULTS:

** The =init.el= section on denote-silo

#+begin_src emacs-lisp :tangle "init.el"
(use-package denote-silo
  :ensure t
  ;; Bind these commands to key bindings of your choice.
  :commands ( denote-silo-create-note
              denote-silo-open-or-create
              denote-silo-select-silo-then-command
              denote-silo-dired
              denote-silo-cd )
  :config
  ;; Add your silos to this list.  By default, it only includes the
  ;; value of the variable `denote-directory'.
  (setq denote-silo-directories
        (list denote-directory
              "~/Documents/Notes/"
              "~/Documents/Huiswiki/"
              "~/Documents/Recipebook/"
              "~/Documents/Bikes/"
              "~/Documents/Systemwiki/")))
#+end_src

#+RESULTS:
: t

** The =init.el= section on denote-journal

#+begin_src emacs-lisp :tangle "init.el"
(use-package denote-journal
  :ensure t
  ;; Bind those to some key for your convenience.
  :commands ( denote-journal-new-entry
              denote-journal-new-or-existing-entry
              denote-journal-link-or-create-entry )
  :hook (calendar-mode . denote-journal-calendar-mode)
  :config
  ;; Use the "journal" subdirectory of the `denote-directory'.  Set this
  ;; to nil to use the `denote-directory' instead.
  (setq denote-journal-directory
        (expand-file-name "Journal" denote-directory))
  ;; Default keyword for new journal entries. It can also be a list of
  ;; strings.
  (setq denote-journal-keyword "journal")
  ;; Read the doc string of `denote-journal-title-format'.
  (setq denote-journal-title-format 'day-date-month-year))

#+end_src

#+RESULTS:
| denote-journal-calendar-mode | org--setup-calendar-bindings |

** The =init.el= setup of org-mode

*** The =init.el= main setup of org

Some explanations:
- org-ellipsis: icon when folding a heading
- org-log-done: log timestamp when going from TODO to DONE
- org-hide-emphasis-markers: ?
- org-todo-keywords: Set keywords, multiple TODO sequences can be set but I have not done so yet.

Org refiling is set like this, so I see the full path of the outline. To deal with different headers level and repeating subheadings (e.g. Tasks and Ideas)
#+begin_src 
 (setq org-refile-targets '(("agenda.org" :maxlevel . 1)
      ("personal.org" :maxlevel . 1)
      ("readinglist.org" :maxlevel . 1)
      ("projects.org" :maxlevel . 2)))
 (setq org-refile-use-outline-path 'file)
 (setq org-outline-path-complete-in-steps nil)
#+end_src


#+begin_src emacs-lisp :tangle "init.el"
      ;;; Org-mode (personal information manager)
  (use-package org
    :ensure nil
    :init
    (setq org-directory (expand-file-name "~/Documents/Org/"))
    (setq org-agenda-files (list "agenda.org" "inbox.org" "projects.org" "personal.org" "readinglist.org")) 
    (setq org-agenda-skip-scheduled-if-done t)
    (setq org-imenu-depth 7)

    (add-to-list 'safe-local-variable-values '(org-hide-leading-stars . t))
    (add-to-list 'safe-local-variable-values '(org-hide-macro-markers . t))
    :bind
    ( :map global-map
      ("C-c l" . org-store-link)
      ("C-c a" . org-agenda)
      ("C-c o" . org-open-at-point-global)
      :map org-mode-map
      ;; I don't like that Org binds one zillion keys, so if I want one
      ;; for something more important, I disable it from here.
      ("C-c M-l" . org-insert-last-stored-link)
      ("C-c C-M-l" . org-toggle-link-display)
      ("M-." . org-edit-special) ; alias for C-c ' (mnenomic is global M-. that goes to source)
      :map org-src-mode-map
      ("M-," . org-edit-src-exit) ; see M-. above
      :map narrow-map
      ("b" . org-narrow-to-block)
      ("e" . org-narrow-to-element)
      ("s" . org-narrow-to-subtree))

    ;;;; general settings
    :config
    (setq org-refile-targets '(("agenda.org" :maxlevel . 1)
      ("personal.org" :maxlevel . 1)
      ("readinglist.org" :maxlevel . 1)
      ("projects.org" :maxlevel . 2)))
    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)
    (setq org-hide-emphasis-markers t)
    (setq org-hide-leading-stars nil)
    (setq org-ellipsis "")
    (setq org-cycle-separator-lines 1) ;;number of seperator lines between collapsed headings
    (setq org-structure-template-alist
  	'(("s" . "src")
  	  ("e" . "src emacs-lisp")
  	  ("E" . "src emacs-lisp :results value code :lexical t")
  	  ("t" . "src emacs-lisp :tangle FILENAME")
  	  ("b" . "src bash")
  	  ("x" . "export")
  	  ("q" . "quote")))
    (setq org-fold-catch-invisible-edits 'show) ;; what happens when you edit in a folded block
    (setq org-loop-over-headlines-in-active-region 'start-level)
    (setq org-modules '(ol-info ol-eww))
    (setq org-insert-heading-respect-content t)
    (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
    (setq org-fontify-quote-and-verse-blocks t)
    (setq org-fontify-whole-block-delimiter-line t)
    (setq org-priority-faces nil)
    (setq org-log-done 'time)
    (setq org-table-convert-region-max-lines 20000)
    (setq org-todo-keywords        ; This overwrites the default Doom org-todo-keywords
  	'((sequence
  	   "TODO(t)"           ; A task that is ready to be tackled
  	   "NEXT(n)"           ; An idea, not urgent
  	   "HOLD(h)"            ; To read, not urgent
  	   "|"                 ; needed for separation
  	   "DONE(d)"           ; Task has been completed
  	   "ARCHIVED(a)" )))

    (setq org-agenda-custom-commands
      '(("g" "Get Things Done (GTD)"
         ((agenda ""
                  ((org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'deadline))
                   (org-deadline-warning-days 0)))

          (todo "NEXT"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline))
                 (org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks\n")))


          (tags-todo "planning"
                     ((org-agenda-prefix-format "  %?-12t% s")
                      (org-agenda-overriding-header "\nPlanning\n")))
          (agenda nil
                  ((org-agenda-entry-types '(:deadline))
                   (org-agenda-format-date "")
                   (org-deadline-warning-days 7)
                   (org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
                   (org-agenda-overriding-header "\nDeadlines")))

          (tags-todo "inbox"
                     ((org-agenda-prefix-format "  %?-12t% s")
                      (org-agenda-overriding-header "\nInbox\n")))

          )))))

#+end_src

#+RESULTS:
: org-narrow-to-subtree
*** The =init.el= section with custom org functions

#+begin_src emacs-lisp :tangle "init.el"
(defun log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
(add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)

#+end_src
*** The =init.el= section on org-modern

Setting for org-modern. Its not turned on by default and I would like it to only style the headings. A hook is add to toggle org-hide-leading-stars on toggling org-modern.

#+begin_src emacs-lisp :tangle "init.el"
(use-package org-modern
  :ensure t
  :after org
  :config
  ;; Use custom symbols for heading stars
  (setq org-modern-star '("" "" "" "" "" ""))

  ;; Hide the original asterisks
  (setq org-modern-hide-stars nil)

  ;; Keep indentation reasonable
  (setq org-indent-indentation-per-level 2)

  ;; Disable other org-modern features
  (setq org-modern-table nil)
  (setq org-modern-list nil)
  (setq org-modern-block-name nil)
  (setq org-modern-checkbox nil)
  (setq org-modern-priority nil)
  (setq org-modern-tag nil)
  (setq org-modern-timestamp nil)
  (setq org-modern-keyword nil)
  (setq org-modern-todo nil)
  (setq org-modern-horizontal-rule nil))

(add-hook 'org-modern-mode-hook
          (lambda ()
            (setq org-hide-leading-stars org-modern-mode)))
#+end_src

#+RESULTS:
| org-modern-mode-set-explicitly | #[nil ((setq org-hide-leading-stars org-modern-mode)) nil] |

*** The =init.el= section with org-capture templates

Main capture templates. The main idea is:
- Main capture notes are placed in inbox.org
  - Main: inbox, these are to be refiled/deleted/to be done etc
  - To Read: Not import and for later.
    
#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package org-capture
       :ensure nil
       :bind ("C-c c" . org-capture)
       :config

       (setq org-capture-templates
             `(("e" "Emacs Inbox" entry
                (file+headline "projects.org" "emacs")
                ,(concat "* %^{Title}\n"
                         ":PROPERTIES:\n"
                         ":CAPTURED: %U\n"
                         ":END:\n\n"
                         "%i\n%?\n")
                :empty-lines-after 1)
   	    ("i" "Inbox" entry
                (file+headline "inbox.org" "Inbox")
                ,(concat "* %^{Title}\n"
                         ":PROPERTIES:\n"
                         ":CAPTURED: %U\n"
                         ":END:\n\n"
                         "%i\n%?\n")
                :empty-lines-after 1)
               ("r" "Wishlist" entry
                (file+olp "inbox.org" "Whishlist")
                ,(concat "* %^{Title} %^g\n"
                         ":PROPERTIES:\n"
                         ":CAPTURED: %U\n"
                         ":END:\n\n"
                         "%i\n%?\n")
                :empty-lines-after 1))))
#+end_src

#+RESULTS:
: org-capture

*** The =init.el= section with org templates (general)

#+begin_src emacs-lisp :tangle "init.el"
(defun steven/recipe-template ()
  "Insert my Org recipe template."
  (interactive)
  (insert
   (concat
    "* Title\n\n"
    "** Info\n"
    "Categorie: Maaltijden|Ontbijt\n"
    "Bron:\n"
    "Pagina:\n"
    "Bereidingstijd:\n"
    "Personen:\n\n"
    "** Ingrediënten\n"
    "- [ ]\n"
    "- [ ]\n\n"
    "** Bereiding\n"
    "1. ")))

#+end_src

#+RESULTS:
: steven/recipe-template

*** The =init.el= setup of org-babel
Load languages for source blocks and dont ask for confirmation to run
#+begin_src emacs-lisp :tangle "init.el"
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (python     . t)
      (shell      . t)))

  (setq org-confirm-babel-evaluate
      (lambda (lang body)
        (not (member lang '("emacs-lisp" "python" "shell" "yaml" )))))

#+end_src

*** The =init.el= setup of org-cliplink

#+begin_src emacs-lisp :tangle "init.el"
(use-package org-cliplink
  :ensure t
  :commands (org-cliplink)
  :after org
  :bind (:map org-mode-map
         ("C-c l" . org-cliplink)))

#+end_src


** The =init.el= section for elfeed setup

My elfeed feeds list is placed in: [[file:elfeed-feeds.el][elfeed-feeds.el]]

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package elfeed
          :ensure t
          :hook
          (elfeed-show-mode . visual-line-mode)
          :bind
          ("C-c e" . elfeed)
          :config
          (load-file "~/.config/emacs/elfeed-feeds.el")
          )
#+END_SRC  

This is a function to style the search mode (based on [[https://github.com/rougier/nano-elfeed/blob/master/nano-elfeed.el][link]])

#+begin_src emacs-lisp :tangle "init.el"
  (require 'elfeed)

  (defun nano-elfeed-entry (title subtitle date tags unread &optional no-newline)
    (let* ((foreground-color (if unread
                                 (face-foreground 'default)
                               (face-foreground 'font-lock-comment-face nil t)))
           (background-color (face-background 'highlight))
           (border-color     (face-background 'default))
           (face-upper    `(:foreground ,foreground-color
                            :background ,background-color
                            :overline ,border-color))
           (face-title    `(:foreground ,foreground-color
                            :background ,background-color
                            :weight ,'bold
                            :overline ,border-color))
           (face-subtitle `(:foreground ,foreground-color
                            :background ,background-color
                            :family "Roboto Mono"
                            :height 170
                            :underline nil
                            ))
           (face-lower    `(:foreground ,foreground-color
                            :background ,background-color
                            :underline nil
                            ))
           (window-width (window-width))
           (title-max-width (- window-width 10))
           (indicator  (if unread "  " "  ")))
      (insert
              (propertize indicator 'face face-title)
              (propertize (truncate-string-to-width subtitle title-max-width nil nil "...") 'face face-title 'elfeed-entry t)
              (propertize " " 'display "\n"))
      (insert "   " 
              (propertize title 'face face-upper)
              " | "
              (propertize date 'face face-subtitle)
              " | "
              (propertize (string-join tags " ") 'face 'elfeed-search-tag-face))
       ))

  (defun nano-elfeed-search-print-entry (entry)
    "Alternative printing of elfeed entries using SVG tags."

    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title)
                      (elfeed-entry-title entry) ""))
           (unread (member 'unread (elfeed-entry-tags entry)))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title (when feed
                         (or (elfeed-meta feed :title)
                             (elfeed-feed-title feed)))))

      (nano-elfeed-entry feed-title title date tags  unread t)) )

  (defun nano-elfeed-search-mode ()
    (setq left-fringe-width 0
          right-fringe-width 0
          left-margin-width 0
          right-margin-width 0)
    (set-window-buffer nil (current-buffer))

    (setq hl-line-overlay-priority 100)
    (hl-line-mode -1)
    (setq cursor-type nil)
    (face-remap-add-relative 'hl-line :inherit 'nano-faded-i)
    (hl-line-mode t)
    )

  (defun nano-elfeed-show-mode ()
    (visual-line-mode)
  ;;  (setq truncate-lines t)
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (setq-local truncate-lines nil)
      (setq-local shr-width 79)
      ;; (setq header-line-format nil)
      ;; (face-remap-set-base 'default '(:height 140))
      (set-buffer-modified-p nil)))

  (defun nano-elfeed-next-entry ()
    (interactive)
    (text-property-search-forward 'elfeed-entry t))

  (defun nano-elfeed-prev-entry ()
    (interactive)
    (text-property-search-backward 'elfeed-entry t))

  (defun nano-elfeed-show-next ()
    "Show the next item in the elfeed-search buffer."
    (interactive)
    (funcall elfeed-show-entry-delete)
    (with-current-buffer (elfeed-search-buffer)
      (when elfeed-search-remain-on-entry
        (nano-elfeed-next-entry))
      (call-interactively #'elfeed-search-show-entry)))

  (defun nano-elfeed-show-prev ()
    "Show the previous item in the elfeed-search buffer."
    (interactive)
    (funcall elfeed-show-entry-delete)
    (with-current-buffer (elfeed-search-buffer)
      (when elfeed-search-remain-on-entry (forward-line 1))
      (nano-elfeed-prev-entry)
      (call-interactively #'elfeed-search-show-entry)))

  (setq elfeed-search-filter "@12-hours-ago +unread +news"          
        elfeed-search-print-entry-function
             #'nano-elfeed-search-print-entry)

  (bind-key "<down>" #'nano-elfeed-next-entry 'elfeed-search-mode-map)
  (bind-key "n" #'nano-elfeed-next-entry 'elfeed-search-mode-map)

  (bind-key "<up>" #'nano-elfeed-prev-entry 'elfeed-search-mode-map)
  (bind-key "p" #'nano-elfeed-prev-entry 'elfeed-search-mode-map)

  (bind-key "p" #'elfeed-show-prev 'elfeed-show-mode-map)
  (bind-key "n" #'nano-elfeed-show-next 'elfeed-show-mode-map)

  ;(add-hook 'elfeed-search-mode-hook #'nano-elfeed-search-mode)
  ;(add-hook 'elfeed-show-mode-hook #'nano-elfeed-show-mode)

#+end_src

#+RESULTS:
: nano-elfeed-show-next

This is a function to open some feeds in eww readable mode, I found that for example with the Guardian and NRC this works quite well.
*Not implemented yet*. This now only works from the 'search' mode in elfeed, not during 'show' mode. Not sure what is better.
*Note:* define-key causes and error during init since when this is run 'elfeed-search-mode-map' is not yet available!
#+begin_src emacs-lisp :tangle "init.el"
(defun steven/elfeed-eww-readable ()
   "Open current elfeed entry in eww with readable mode."
   (interactive)
   (let ((link (elfeed-entry-link (elfeed-search-selected :single))))
     (eww link)
     (add-hook 'eww-after-render-hook #'eww-readable nil t)))

;; (define-key elfeed-search-mode-map (kbd "e") 'steven/elfeed-eww-readable)
#+end_src

Play youtube videos with mpv (CLI tool)
#+begin_src emacs-lisp :tangle "init.el"
  (defun steven/elfeed-play-with-mpv ()
     "Play entry link with mpv."
     (interactive)
     (let ((entry (if (eq major-mode  'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :ignore-region))))
          (when entry 
             (message "Opening %s with mpv..." (elfeed-entry-link entry))
             (start-process "elfeed-mpv" nil "mpv" (elfeed-entry-link entry)))))

;; (define-key elfeed-search-mode-map (kbd "v") 'steven/elfeed-play-with-mpv)
;; (define-key elfeed-show-mode-map (kbd "v") 'steven/elfeed-play-with-mpv)
#+end_src

** The =init.el= section for which-key setup
The settings speak for themselves I think. Still need to play around to see what I like.
#+begin_src emacs-lisp :tangle "init.el"
(use-package which-key
  :ensure nil ; built into Emacs 30
  :hook (after-init . which-key-mode)
  :config
  (setq which-key-separator "  ")
  (setq which-key-prefix-prefix "... ")
  (setq which-key-max-display-columns 3)
  (setq which-key-idle-delay 1.5)
  (setq which-key-idle-secondary-delay 0.25)
  (setq which-key-add-column-padding 1)
  (setq which-key-max-description-length 40))

#+end_src

** The =init.el= setup of beframe
#+begin_src emacs-lisp :tangle "init.el"
    ;;; Frame-isolated buffers
  ;; Another package of mine.  Read the manual:
  ;; <https://protesilaos.com/emacs/beframe>.

  (require 'beframe)

  ;; This is the default value.  Write here the names of buffers that
  ;; should not be beframed.
  (setq beframe-global-buffers '("*scratch*" "*Messages*" "*Backtrace*"))

  (beframe-mode 1)

  ;; Bind Beframe commands to a prefix key, such as C-c b:
  (define-key global-map (kbd "C-c b") #'beframe-prefix-map)
  ;; OR use the transient instead of the prefix map:
  (define-key global-map (kbd "C-c b") #'beframe-transient)

#+end_src

** The =init.el= section with TRAMP settings
/This is turned off for now./
+begin_src emacs-lisp :tangle "init.el"
  (setenv "SSH_AUTH_SOCK" (getenv "SSH_AUTH_SOCK"))
  (setq tramp-use-ssh-controlmaster-option nil)
  (add-to-list 'tramp-connection-properties
  	     (list ".*" "remote-shell" "/bin/bash"))
  (setq tramp-ssh-controlmaster-options
        "-o ControlMaster=no -o ControlPath=none")
+end_src

** The =init.el= setup of notmuch email

This email in emacs is configured using multiple steps. Since I am using Proton Mail, I need to use a app called ~Proton Mail Bridge~ to decrypt my email and provide an IMAP service so I can have all mail locally. Secondly, emacs requires all mail to be in text format (called Maildir), we use a tool call ~mbsync~ (or isync) to sync all email to a local folder /.mail. We then use an a tool called ~notmuch~. I not sure yet what this does, but I think it is essentially the email program (like Thunderbird or Apple Mail).
Steps in a list:
1. Proton Bridge should be running and online
2. mbsync (isync) installed and configured: [[file:~/.config/isyncrc][isyncrc on Mac]]
3. notmuch should be installed and configured (simply run notmuch in shell)
4. Sync email using:
   #+begin_src bash
     mbsync proton
     notmuch new
   #+end_src

Setting for notmuch client in emacs are below:
#+begin_src emacs-lisp :tangle "init.el"
;;; Notmuch (mail indexer and mail user agent (MUA))

;; I installed notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(use-package notmuch
  :load-path "/usr/local/share/emacs/site-lisp/notmuch/"
  :defer t
  :commands (notmuch notmuch-mua-new-mail)
  :config
   (setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key [105] :sort-order newest-first :search-type nil)
       (:name "unread" :query "tag:unread" :key [117] :sort-order newest-first)
       (:name "flagged" :query "tag:flagged" :key [102] :sort-order newest-first)
       (:name "sent" :query "tag:sent" :key [116] :sort-order newest-first)
       (:name "drafts" :query "tag:draft" :key [100] :sort-order newest-first)
       (:name "Winkels" :query "folder:\"Folders/🏬 Winkels\"" :sort-order newest-first :count-query "tag:unread")
       (:name "Gmail" :query "folder:\"Folders/✉️ Gmail\"" :sort-order newest-first :count-query "tag:unread and folder:\"Folders/✉️ Gmail\"")
       (:name "Tijdelijk" :query "folder:\"Folders/⏱️ Tijdelijk\"" :sort-order newest-first :count-query "tag:unread")
       (:name "🧔🏻‍♂️ Persoonlijk" :query "folder:\"Folders/🧔🏻‍♂️ Persoonlijk\"" :sort-order newest-first :count-query "tag:unread")
       (:name "🗞️ Newsletters" :query "folder:\"Folders/🗞️ Newsletters\"" :sort-order newest-first :count-query "tag:unread")
       (:name "❤️‍🩹 Zorg" :query "folder:\"Folders/❤️‍🩹 Zorg\"" :sort-order newest-first :count-query "tag:unread")
       (:name "🏡 Huishouden" :query "folder:\"Folders/🏡 Huishouden\"" :sort-order newest-first :count-query "tag:unread")
       (:name "📰 Accounts" :query "folder:\"Folders/📰 Accounts\"" :sort-order newest-first :count-query "tag:unread"))))
#+end_src

#+RESULTS:
: t

*** The =init.el= section with gluecode for notmuch and org

#+begin_src emacs-lisp :tangle "init.el"
(use-package ol-notmuch
  :ensure t
  :after notmuch)
#+end_src

#+RESULTS:

*** The =init.el= section with gluecode for notmuch and bookmarks

#+begin_src emacs-lisp :tangle "init.el"
(defun my-notmuch-bookmark-jump (bookmark)
  "Jump to a notmuch saved search bookmark."
  (let ((search (bookmark-prop-get bookmark 'notmuch-search)))
    (notmuch-search search)))

(defun my-notmuch-bookmark-set ()
  "Set a bookmark for the current notmuch search buffer."
  (interactive)
  (unless (derived-mode-p 'notmuch-search-mode)
    (user-error "Not in a notmuch search buffer"))
  (let* ((name (read-string "Bookmark name: "))
         ;; Evaluate the variable, don't quote it
         (search notmuch-search-query-string)
         ;; Build the bookmark record
         (bookmark (list (cons 'notmuch-search search)
                         (cons 'handler #'my-notmuch-bookmark-jump))))
    ;; Store it properly
    (bookmark-store name bookmark nil)
    (message "Stored notmuch search bookmark: %s (%s)" name search)))
#+end_src

** The =init.el= section magit setup

Some notes on settings:
#+begin_src emacs-lisp
:init
(setq magit-section-visibility-indicator '(magit-fringe-bitmap> . magit-fringe-bitmapv))
#+end_src
- This is part of the =:init= section, which is evaluated before the package is loaded.
- It sets a visual indicator (magit-section-visibility-indicator) in the fringe (the margin area of the buffer) for showing whether Magit sections are expanded or collapsed.
- The value is a cons cell of bitmaps: '('magit-fringe-bitmap> . 'magit-fringe-bitmapv), i.e. using arrows to indicate expansion direction (like right/vertical).


#+begin_src emacs-lisp
 (setq git-commit-summary-max-length 50)
#+end_src
- Sets the maximum length of the Git commit summary line to 50 characters (a conventional Git best practice).

#+begin_src emacs-lisp
(setq git-commit-style-convention-checks '(non-empty-second-line))
#+end_src

- This sets which style checks are enabled when writing a commit message.
- Only the non-empty-second-line check is enabled, which ensures the second line of the commit message isn't empty (a Git best practice).
- The check for overlong-summary-line was removed deliberately.

#+begin_src emacs-lisp
(setq magit-diff-refine-hunk t)
#+end_src

- Enables inline diff highlighting (refinement) for the current hunk only in d iffs. Makes it easier to see exactly what changed within modified lines.

#+begin_src emacs-lisp :tangle "init.el"
;;; Interactive and powerful git front-end (Magit)
(use-package transient
  :ensure t
  :config
  (setq transient-show-popup 0.5))

(use-package magit
  :ensure t
  :bind
  ( :map global-map
    ("C-c g" . magit-status))
  :init
  (setq magit-section-visibility-indicator '(magit-fringe-bitmap> . magit-fringe-bitmapv))
  :config
  (setq git-commit-summary-max-length 50)
  ;; NOTE 2023-01-24: I used to also include `overlong-summary-line'
  ;; in this list, but I realised I do not need it.  My summaries are
  ;; always in check.  When I exceed the limit, it is for a good
  ;; reason.
  (setq git-commit-style-convention-checks '(non-empty-second-line))

  (setq magit-diff-refine-hunk t)

  ;; Show icons for files in the Magit status and other buffers.
  (with-eval-after-load 'magit
    (setq magit-format-file-function #'magit-format-file-nerd-icons)))

#+end_src

#+RESULTS:
: magit-status


** The =init.el= setup of pdf-tool

pdftools needs a server (epdfinfo) to run for opening pdf files. The server is configured automatically on installation of the package. However, this configuration is not universal between Linux and macOS. For now, this only works on macOS, since I open pdf files there regularly.

#+begin_src emacs-lisp :tangle "init.el"
(when (eq system-type 'darwin)
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install))

  (use-package org-pdftools
    :hook (org-mode . org-pdftools-setup-link)))
#+end_src

#+RESULTS:

** The =init.el= setup of weather in emacs (biome.el)

#+begin_src emacs-lisp :tangle "init.el"
(use-package biome
  :ensure t
  :bind
  :config
   (setq biome-query-coords
      '(("Eindhoven" 51.43531 5.526096)
        ("Groningen" 53.21962, 6.56706)
        ("Belo Horizonte" -19.91968, -43.94013)))
   (add-to-list 'biome-presets-alist
             '("biome-query-preset-101" :normal
               ((:name . "Weather Forecast") (:group . "daily")
                (:params
                 ("daily" "sunshine_duration" "precipitation_sum"
                  "temperature_2m_min" "temperature_2m_max")
                 ("past_days" . 2) ("forecast_days" . 6)
                 ("longitude" . 5.526096) ("latitude" . 51.43531)
                 ("timezone" . "CET")))))
   ;;Invoke with M-x biome-preset
)

#+end_src

#+RESULTS:
: t

** The =init.el= section with center document mode
This is copied from the 'Emacs From Scratch' series. See [[https://github.com/daviwil/emacs-from-scratch][GitHub - daviwil/emacs-from-scratch]]

#+begin_src emacs-lisp :tangle "init.el"
(defvar center-document-desired-width 80
  "The desired width of a document centered in the window.")

(defun center-document--adjust-margins ()
  ;; Reset margins first before recalculating
  (set-window-parameter nil 'min-margins nil)
  (set-window-margins nil nil)

  ;; Adjust margins if the mode is on
(when center-document-mode
    (let ((margin-width (max 0
                             (truncate
                              (/ (- (window-width)
                                    center-document-desired-width)
                                 2.0)))))
      (when (> margin-width 0)
        (set-window-parameter nil 'min-margins '(0 . 0))
        (set-window-margins nil margin-width margin-width)))))
#+end_src

#+RESULTS:
: center-document--adjust-margins


#+begin_src emacs-lisp :tangle "init.el"
(define-minor-mode center-document-mode
  "Toggle centered text layout in the current buffer."
  :lighter " Centered"
  :group 'editing
  (if center-document-mode
      (add-hook 'window-configuration-change-hook #'center-document--adjust-margins 'append 'local)
    (remove-hook 'window-configuration-change-hook #'center-document--adjust-margins 'local))
  (center-document--adjust-margins))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'center-document-mode)
(add-hook 'markdown-mode-hook #'center-document-mode)
(add-hook 'text-mode-hook #'center-document-mode)
#+end_src


** The =init.el= section to load show-font 

A package by Prot to display font styles

#+begin_src emacs-lisp :tangle "init.el"
(use-package show-font
  :ensure t
  :bind
  (("C-c s f" . show-font-select-preview)
   ("C-c s t" . show-font-tabulated)))
#+end_src

#+RESULTS:
: show-font-tabulated

** The (OLD) section on mode and header lines

#+begin_src emacs-lisp
(setq-default mode-line-format "")
(setq-default header-line-format
  '(:eval
    (let ((prefix (cond (buffer-read-only     '("RO" . nano-default-i))
                        ((buffer-modified-p)  '("**" . nano-critical-i))
                        (t                    '("RW" . nano-faded-i))))
          (mode (concat "(" (downcase (cond ((consp mode-name) (car mode-name))
                                            ((stringp mode-name) mode-name)
                                            (t "unknow")))
                        " mode)"))
          (coords (format-mode-line "%c:%l ")))
      (list
       (propertize " " 'face (cdr prefix)  'display '(raise -0.25))
       (propertize (car prefix) 'face (cdr prefix))
       (propertize " " 'face (cdr prefix) 'display '(raise +0.25))
       (propertize (format-mode-line " %b ") 'face 'nano-strong)
       (propertize mode 'face 'header-line)
       (propertize " " 'display `(space :align-to (- right ,(length coords))))
       (propertize coords 'face 'nano-faded)))))


#+end_src

#+RESULTS:
| :eval | (let ((prefix (cond (buffer-read-only '(RO . nano-face-tag-faded)) ((buffer-modified-p) '(** . nano-face-tag-popout)) (t '(RW . nano-face-tag-faded)))) (mode (concat ( (downcase (cond ((consp mode-name) (car mode-name)) ((stringp mode-name) mode-name) (t unknow)))  mode))) (coords (format-mode-line %c:%l ))) (list (propertize   'face (cdr prefix) 'display '(raise -0.25)) (propertize (car prefix) 'face (cdr prefix)) (propertize   'face (cdr prefix) 'display '(raise 0.25)) (propertize (format-mode-line  %b ) 'face 'nano-face-strong) (propertize mode 'face 'header-line) (propertize   'display `(space :align-to (- right ,(length coords)))) (propertize coords 'face 'nano-face-faded))) |

Now set specific modelines (elfeed and pdf view mode)
#+begin_src emacs-lisp


#+end_src


#+begin_src emacs-lisp
(add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
(add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
(add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
#+end_src


** The (OLD) theme (NANO) setup

Nano-theme, copied from gitpage, note that some settings regarding the mode and headerline are set in here! I need to figure out how this is set uo

#+begin_src emacs-lisp
  (defface nano-default '((t)) "")   (defface nano-default-i '((t)) "")
  (defface nano-highlight '((t)) "") (defface nano-highlight-i '((t)) "")
  (defface nano-subtle '((t)) "")    (defface nano-subtle-i '((t)) "")
  (defface nano-faded '((t)) "")     (defface nano-faded-i '((t)) "")
  (defface nano-salient '((t)) "")   (defface nano-salient-i '((t)) "")
  (defface nano-popout '((t)) "")    (defface nano-popout-i '((t)) "")
  (defface nano-strong '((t)) "")    (defface nano-strong-i '((t)) "")
  (defface nano-critical '((t)) "")  (defface nano-critical-i '((t)) "")

  (defun nano-set-face (name &optional foreground background weight)
    "Set NAME and NAME-i faces with given FOREGROUND, BACKGROUND and WEIGHT"

    (apply #'set-face-attribute `(,name nil
                                  ,@(when foreground `(:foreground ,foreground))
                                  ,@(when background `(:background ,background))
                                  ,@(when weight `(:weight ,weight))))
    (apply #'set-face-attribute `(,(intern (concat (symbol-name name) "-i")) nil
                                  :foreground ,(face-background 'nano-default)
                                  ,@(when foreground `(:background ,foreground))
                                  :weight regular)))

  (defun nano-link-face (sources faces &optional attributes)
    "Make FACES to inherit from SOURCES faces and unspecify ATTRIBUTES."

    (let ((attributes (or attributes
                          '( :foreground :background :family :weight
                             :height :slant :overline :underline :box))))
      (dolist (face (seq-filter #'facep faces))
        (dolist (attribute attributes)
          (set-face-attribute face nil attribute 'unspecified))
        (set-face-attribute face nil :inherit sources))))

  (defun nano-install-theme ()
    "Install THEME"

    (set-face-attribute 'default nil
                        :foreground (face-foreground 'nano-default)
                        :background (face-background 'nano-default))
    (dolist (item '((nano-default .  (variable-pitch variable-pitch-text
                                      fixed-pitch fixed-pitch-serif))
                    (nano-highlight . (hl-line highlight))
                    (nano-subtle .    (match region
                                       lazy-highlight widget-field))
                    (nano-faded .     (shadow
                                       font-lock-comment-face
                                       font-lock-doc-face
                                       icomplete-section
                                       completions-annotations))
                    (nano-popout .    (warning
                                       font-lock-string-face))
                    (nano-salient .   (success link
                                       help-argument-name
                                       custom-visibility
                                       font-lock-type-face
                                       font-lock-keyword-face
                                       font-lock-builtin-face
                                       completions-common-part))
                    (nano-strong .    (font-lock-function-name-face
                                       font-lock-variable-name-face
                                       icomplete-first-match
                                       minibuffer-prompt))
                    (nano-critical .  (error
                                       completions-first-difference))
                    (nano-faded-i .   (help-key-binding))
                    (nano-default-i . (custom-button-mouse
                                       isearch))
                    (nano-critical-i . (isearch-fail))
                    ((nano-subtle nano-strong) . (custom-button
                                                  icomplete-selected-match))
                    ((nano-faded-i nano-strong) . (show-paren-match))))
      (nano-link-face (car item) (cdr item)))

    ;; Mode & header lines 
    (set-face-attribute 'header-line nil
                        :background 'unspecified
                        :underline nil
                        :box `( :line-width 1
                                :color ,(face-background 'nano-default))
                        :inherit 'nano-subtle)
    (set-face-attribute 'mode-line nil
                        :background (face-background 'default)
                        :underline (face-foreground 'nano-faded)
                        :height 40 :overline nil :box nil)
    (set-face-attribute 'mode-line-inactive nil
                        :background (face-background 'default)
                        :underline (face-foreground 'nano-faded)
                        :height 40 :overline nil :box nil))

  (defun nano-light (&rest args)
    "NANO light theme (based on material colors)"

    (interactive)
    (nano-set-face 'nano-default "#37474F" "#FFFFFF") ;; Blue Grey / L800
    (nano-set-face 'nano-strong "#000000" nil 'regular) ;; Black
    (nano-set-face 'nano-highlight nil "#FAFAFA") ;; Very Light Grey FAFAFA
    (nano-set-face 'nano-subtle nil "#ECEFF1") ;; Blue Grey / L50
    (nano-set-face 'nano-faded "#90A4AE") ;; Blue Grey / L300
    (nano-set-face 'nano-salient "#673AB7") ;; Deep Purple / L500
    (nano-set-face 'nano-popout "#FFAB91") ;; Deep Orange / L200
    (nano-set-face 'nano-critical "#FF6F00") ;; Amber / L900
    (nano-install-theme))
    
  (defun nano-dark (&rest args)
    "NANO dark theme (based on nord colors)"

    (interactive)
    (nano-set-face 'nano-default "#ECEFF4" "#2E3440") ;; Snow Storm 3 
    (nano-set-face 'nano-strong "#ECEFF4" nil 'regular) ;; Polar Night 0
    (nano-set-face 'nano-highlight nil "#3B4252")  ;; Polar Night 1
    (nano-set-face 'nano-subtle nil "#434C5E") ;; Polar Night 2 
    (nano-set-face 'nano-faded "#677691") ;; 
    (nano-set-face 'nano-salient "#81A1C1")  ;; Frost 2
    (nano-set-face 'nano-popout "#D08770") ;; Aurora 1
    (nano-set-face 'nano-critical "#EBCB8B") ;; Aurora 2
    (nano-install-theme))

#+end_src

#+RESULTS:
: nano-dark

*Move to nano-install*
Section to set the elfeed theme (only needed for pure nano theme)
#+begin_src emacs-lisp
(with-eval-after-load 'elfeed
  (custom-set-faces
  '(elfeed-search-title-face ((t (:inherit nano-default))))
  '(elfeed-search-unread-title-face ((t (:inherit nano-strong))))
  '(elfeed-search-date-face ((t (:inherit nano-default))))
  '(elfeed-search-feed-face ((t (:inherit nano-default))))
  '(elfeed-search-tag-face ((t (:inherit nano-salient))))))
#+end_src

Add command line theme switcher (in this way I can switch theme when loading emacs like emacs -dark):
#+begin_src emacs-lisp
(add-to-list 'command-switch-alist '("-dark"  . nano-dark))
(add-to-list 'command-switch-alist '("-light" . nano-light))
(if (member "-dark" command-line-args) (nano-dark) (nano-light))
#+end_src

#+RESULTS:
: nano-dark

** The (OLD) theme (MODUS) setup

I am using just the head and modeline setup of nano, and then using the modus theme faces. Its now a bit of a hacky solution by still defining the nano colours for use in the modeline setup.
#+begin_src emacs-lisp 
(use-package modus-themes
  :ensure t
  :config
  (load-theme 'modus-operandi-tinted :no-confirm-loading))


(nano-set-face 'nano-default "#37474F" "#FFFFFF") ;; Blue Grey / L800
(nano-set-face 'nano-strong "#000000" nil 'regular) ;; Black
(nano-set-face 'nano-highlight nil "#FAFAFA") ;; Very Light Grey FAFAFA
(nano-set-face 'nano-subtle nil "#ECEFF1") ;; Blue Grey / L50
(nano-set-face 'nano-faded "#90A4AE") ;; Blue Grey / L300
(nano-set-face 'nano-salient "#673AB7") ;; Deep Purple / L500
(nano-set-face 'nano-popout "#FFAB91") ;; Deep Orange / L200
(nano-set-face 'nano-critical "#FF6F00") ;; Amber / L900

(set-face-attribute 'header-line nil
                    :background 'unspecified
                    :underline nil
                    :box `( :line-width 1
                            :color ,(face-background 'nano-default))
                    :inherit 'nano-subtle)

(set-face-attribute 'mode-line nil
                    :background (face-background 'default)
                    :underline (face-foreground 'nano-faded)
                    :height 40 :overline nil :box nil)
(set-face-attribute 'mode-line-inactive nil
                    :background (face-background 'default)
                    :underline (face-foreground 'nano-faded)
                    :height 40 :overline nil :box nil)


#+end_src

#+RESULTS:


